<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Omniperf Examples</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Omniperf Examples</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#instructions-for-loading-omniperf-on-frontier">Instructions for loading Omniperf on Frontier:</a></li>
<li><a href="#instructions-for-running-examples-on-perlmutter">Instructions for running examples on Perlmutter:</a>
<ul>
<li><a href="#exercise-1-launch-parameter-tuning">Exercise 1: Launch Parameter Tuning</a>
<ul>
<li><a href="#initial-roofline-analysis">Initial Roofline Analysis:</a></li>
<li><a href="#exercise-instructions">Exercise instructions:</a></li>
<li><a href="#omniperf-command-line-comparison-feature">Omniperf Command Line Comparison Feature</a></li>
<li><a href="#more-kernel-filtering">More Kernel Filtering</a></li>
<li><a href="#solution-roofline">Solution Roofline</a></li>
<li><a href="#roofline-comparison">Roofline Comparison</a></li>
<li><a href="#summary-and-take-aways">Summary and Take-aways</a></li>
</ul></li>
<li><a href="#exercise-2-lds-occupancy-limiter">Exercise 2: LDS Occupancy Limiter</a>
<ul>
<li><a href="#initial-roofline-analysis-1">Initial Roofline Analysis</a></li>
<li><a href="#exercise-instructions-1">Exercise Instructions:</a></li>
<li><a href="#solution-roofline-1">Solution Roofline</a></li>
<li><a href="#roofline-comparison-1">Roofline Comparison</a></li>
<li><a href="#summary-and-take-aways-1">Summary and Take-aways</a></li>
</ul></li>
<li><a href="#exercise-3-register-occupancy-limiter">Exercise 3: Register Occupancy Limiter</a>
<ul>
<li><a href="#initial-roofline-analysis-2">Initial Roofline Analysis</a></li>
<li><a href="#exercise-instructions-2">Exercise Instructions:</a></li>
<li><a href="#solution-roofline-2">Solution Roofline</a></li>
<li><a href="#roofline-comparison-2">Roofline Comparison</a></li>
<li><a href="#summary-and-take-aways-2">Summary and Take-aways</a></li>
</ul></li>
<li><a href="#exercise-4-strided-data-access-patterns-and-how-to-find-them">Exercise 4: Strided Data Access Patterns (and how to find them)</a>
<ul>
<li><a href="#initial-roofline-analysis-3">Initial Roofline Analysis</a></li>
<li><a href="#exercise-instructions-3">Exercise Instructions:</a></li>
<li><a href="#solution-roofline-analysis">Solution Roofline Analysis</a></li>
<li><a href="#roofline-comparison-3">Roofline Comparison</a></li>
<li><a href="#summary-and-take-aways-3">Summary and Take-aways</a></li>
</ul></li>
<li><a href="#exercise-5-algorithmic-optimizations">Exercise 5: Algorithmic Optimizations</a>
<ul>
<li><a href="#initial-roofline-analysis-4">Initial Roofline Analysis</a></li>
<li><a href="#exercise-instructions-4">Exercise Instructions:</a></li>
<li><a href="#solution-roofline-analysis-1">Solution Roofline Analysis</a></li>
<li><a href="#roofline-comparison-4">Roofline Comparison</a></li>
<li><a href="#summary-and-take-aways-4">Summary and Take-aways</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="instructions-for-loading-omniperf-on-frontier">Instructions for loading Omniperf on Frontier:</h1>
<p>To load the appropriate environment, you should be able to simply run:</p>
<pre><code>module use  /autofs/nccs-svm1_sw/crusher/amdsw/modules
module load PrgEnv-amd amd omniperf</code></pre>
<p>This should pull in Omniperf, ROCm, and all the dependencies necessary to run our exercises. It is worthy of note that this version of Omniperf is a pre-release candidate for 1.1.0.</p>
<p>The module use command will make the omniperf/1.1.0-PR1 pre-release version the default and then the module load omniperf will get this version.</p>
<blockquote>
<p>Note: By default this loads ROCm 5.3.0, which may not show the issue talked about in Exercise 3: Register Occupancy Limiter</p>
</blockquote>
<p>To allocate an interactive job on Frontier:</p>
<pre><code>salloc -N 1 -p batch --reservation=hip_training_2023_10_16 --gpus=1 -t 10:00 -A &lt;project&gt;</code></pre>
<p>Use your project ID in the project field. If you’re unsure of what projects are available to you, run the above command without the <code>-A</code> option, and it will report a list of your valid projects.</p>
<p>Outside our reservation window, you can do:</p>
<pre><code>salloc -N 1 -p batch --gpus=1 -t 10:00 -A &lt;project&gt;</code></pre>
<p>As is usual in this lecture series, the linked Google doc for comments, questions and answers will be at https://docs.google.com/document/d/1aUfzofSgxCn-gkejJHDlh54YX5mRMaj5xkAO7zEZUkQ/edit</p>
<h1 id="instructions-for-running-examples-on-perlmutter">Instructions for running examples on Perlmutter:</h1>
<p>On Perlmutter, the exercise is to compare the performance change on Nvidia GPUs for each type of optimization</p>
<p>To load the appropriate modules,</p>
<pre><code>module load PrgEnv-gnu/8.3.3
module load hip/5.4.3
module load PrgEnv-nvidia/8.3.3
module load cmake

export PATH=${PATH}:${HIP_PATH}</code></pre>
<p>To get an allocation on Perlmutter</p>
<pre><code>salloc -N 1 -q shared -C gpu -c 32 -G 1 -t 30:00 -A ntrain8 --reservation=hip_oct16</code></pre>
<p>Outside the reservation hours use,</p>
<pre><code>salloc -N 1 -q shared -C gpu -c 32 -G 1 -t 30:00 -A ntrain8</code></pre>
<h2 id="exercise-1-launch-parameter-tuning">Exercise 1: Launch Parameter Tuning</h2>
<p>Simple kernel implementing a version of yAx, to demonstrate effects of Launch Parameters on kernel execution time.</p>
<strong>Note:</strong> This exercise was tested on a system with MI210s, on Omniperf version <code>1.0.10</code> and ROCm <code>5.7.0</code>, the section on the omniperf comparison feature currently requires building a release candidate that is newer than Omniperf 1.0.10.
<details>
<summary>
<h3>
Background: Acronyms and terms used in this exercise
</h3>
</summary>
<ul>
<li>
yAx: a vector-matrix-vector product, y<em>A</em>x, where y and x are vectors, and A is a matrix
</li>
<li>
FP(32/16): 32- or 16-bit Floating Point numeric types
</li>
<li>
FLOPs: Floating Point Operations Per second
</li>
<li>
HBM: High Bandwidth Memory is globally accessible from the GPU, and is a level of memory above the L2 cache
</li>
</ul>
</details>
<h3 id="initial-roofline-analysis">Initial Roofline Analysis:</h3>
<p>The roofline model is a way to gauge kernel performance in terms of maximum achievable bandwidth and floating-point operations. It can be used to determine how efficiently a kernel makes use of the available hardware. It is a key tool in initially determining which kernels are performing well, and which kernels should be able to perform better. Below are roofline plots for the yAx kernel in problem.cpp:</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Roofline Legend</th>
<th>Roofline Plot</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise1_problem_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise1_problem_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>These plots were generated by running:</p>
<pre><code>omniperf profile -n problem_roof_only --roof-only --kernel-names -- ./problem.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/problem_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>We see that the kernel’s performance is not near the achievable bandwidth possible on the hardware, which makes it a good candidate to consider optimizing.</p>
<h3 id="exercise-instructions">Exercise instructions:</h3>
<p>From the roofline we were able to see that there is room for improvement in this kernel. One of the first things to check is whether or not we have reasonable launch parameters for this kernel.</p>
<p>To get started, build and run the problem code:</p>
<pre><code>make
./problem.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 2911 milliseconds</code></pre>
<p>The runtime of the problem should be very slow, due to sub-optimal launch parameters. Let’s confirm this hypothesis by looking at the omniperf profile. Start by running:</p>
<pre><code>omniperf profile -n problem --no-roof -- ./problem.exe</code></pre>
<p>This command requires omniperf to run your code a few times to collect all the necessary hardware counters. - <code>-n problem</code> names the workload, meaning that the profile will appear in the <code>./workloads/problem/mi200/</code> directory, if you are profiling on an MI200 device. - <code>--no-roof</code> turns off the roofline, which will save some profiling time by avoiding the collection of achievable bandwidths and FLOPs on the device. - Everything after the <code>--</code> is the command that will be profiled.</p>
<p>After the profiling data is collected, we can view the profile by using this command:</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 --dispatch 1 --metric 7.1.0 7.1.1 7.1.2</code></pre>
<p>This allows us to view nicely formatted profiling data directly in the command line. The command given here has a few arguments that are noteworthy: - <code>-p workloads/problem/mi200</code> must point to the output directory of your profile run. For the above <code>omniperf profile</code> command, this will be <code>workloads/problem/mi200</code>. - <code>--dispatch 1</code> filters kernel statistics by dispatch ID. In this case kernel 0 was a “warm-up” kernel, and kernel 1 is what the code reports timings for. - <code>--metric</code> displays only the requested metrics, in this case we want metrics specific to Launch Parameters: - <code>7.1.0</code> is the Grid Size - <code>7.1.1</code> is the Workgroup Size - <code>7.1.2</code> is the Total Wavefronts Launched</p>
<p>The output of the <code>omniperf analyze</code> command should look something like this:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤══════════════╤══════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │      Sum(ns) │     Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪══════════════╪══════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 755935180.00 │ 755935180.00 │ 755935180.00 │ 100.00 │
│    │  double*)                                │         │              │              │              │        │
╘════╧══════════════════════════════════════════╧═════════╧══════════════╧══════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
7. Wavefront
7.1 Wavefront Launch Stats
╒═════════╤══════════════════╤════════╤════════╤════════╤════════════╕
│ Index   │ Metric           │    Avg │    Min │    Max │ Unit       │
╞═════════╪══════════════════╪════════╪════════╪════════╪════════════╡
│ 7.1.0   │ Grid Size        │ 256.00 │ 256.00 │ 256.00 │ Work items │
├─────────┼──────────────────┼────────┼────────┼────────┼────────────┤
│ 7.1.1   │ Workgroup Size   │  64.00 │  64.00 │  64.00 │ Work items │
├─────────┼──────────────────┼────────┼────────┼────────┼────────────┤
│ 7.1.2   │ Total Wavefronts │   4.00 │   4.00 │   4.00 │ Wavefronts │
╘═════════╧══════════════════╧════════╧════════╧════════╧════════════╛</code></pre>
<p>Looking through this data we see: - Workgroup Size (<code>7.1.1</code>) is 64 threads, which corresponds with the size of a wavefront. - Total Wavefronts (<code>7.1.2</code>) shows that we are launching only 4 Wavefronts.</p>
<p>We can definitely get better performance by adjusting the launch parameters of our kernel. Either try out some new values for the launch bounds, or run the provided solution to see its performance:</p>
<pre><code>cd solution
make
./solution.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 70 ms</code></pre>
<p>We get much better performance with the new launch parameters. Note that in general it can be difficult to find the most optimal launch parameters for a given kernel due to the many factors that impact performance, so determining launch parameters experimentally is usually necessary.</p>
<p>We should also confirm that our updated launch parameters are reported by omniperf, we need to run:</p>
<pre><code>omniperf profile -n solution --no-roof -- ./solution.exe</code></pre>
<p>This command is the same as before, except the workload name has changed to <code>solution</code>. Once the <code>profile</code> command has completed, run:</p>
<pre><code>omniperf analyze -p workloads/solution/mi200 --dispatch 1 --metric 7.1.0 7.1.1 7.1.2</code></pre>
<p>Again, this command largely uses the same arguments as before, except for the workload name. The output should look something like this:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 70115217.00 │ 70115217.00 │  70115217.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
7. Wavefront
7.1 Wavefront Launch Stats
╒═════════╤══════════════════╤═══════════╤═══════════╤═══════════╤════════════╕
│ Index   │ Metric           │       Avg │       Min │       Max │ Unit       │
╞═════════╪══════════════════╪═══════════╪═══════════╪═══════════╪════════════╡
│ 7.1.0   │ Grid Size        │ 131072.00 │ 131072.00 │ 131072.00 │ Work items │
├─────────┼──────────────────┼───────────┼───────────┼───────────┼────────────┤
│ 7.1.1   │ Workgroup Size   │     64.00 │     64.00 │     64.00 │ Work items │
├─────────┼──────────────────┼───────────┼───────────┼───────────┼────────────┤
│ 7.1.2   │ Total Wavefronts │   2048.00 │   2048.00 │   2048.00 │ Wavefronts │
╘═════════╧══════════════════╧═══════════╧═══════════╧═══════════╧════════════╛</code></pre>
<p>Looking through this data we see: - Workgroup Size (<code>7.1.1</code>) corresponds to the first argument of the block launch parameter - Total Wavefronts (<code>7.1.2</code>) corresponds to the first index of the grid launch parameter - Grid size (<code>7.1.0</code>) is Workgroup Size (<code>7.1.1</code>) times Total Wavefronts (<code>7.1.2</code>)</p>
<h3 id="omniperf-command-line-comparison-feature">Omniperf Command Line Comparison Feature</h3>
<p><strong>On releases newer than Omniperf 1.0.10</strong>, the comparison feature of omniperf can be used to quickly compare two profiles. To use this feature, use the command:</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 -p solution/workloads/solution/mi200 --dispatch 1 --metric 7.1.0 7.1.1 7.1.2</code></pre>
<p>This feature sets the first <code>-p</code> argument as the baseline, and the second as the comparison workload. In this case, problem is set as the baseline and is compared to solution. The output should look like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤════════════╤══════════════╤══════════════════════╤══════════════╤══════════════════════╤══════════════╤══════════════════════╤════════╤══════════════╕
│    │ KernelName                               │   Count │ Count      │      Sum(ns) │ Sum(ns)              │     Mean(ns) │ Mean(ns)             │   Median(ns) │ Median(ns)           │    Pct │ Pct          │
╞════╪══════════════════════════════════════════╪═════════╪════════════╪══════════════╪══════════════════════╪══════════════╪══════════════════════╪══════════════╪══════════════════════╪════════╪══════════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 1.0 (0.0%) │ 754934306.50 │ 69702016.5 (-90.77%) │ 754934306.50 │ 69702016.5 (-90.77%) │ 754934306.50 │ 69702016.5 (-90.77%) │ 100.00 │ 100.0 (0.0%) │
│    │  double*)                                │         │            │              │                      │              │                      │              │                      │        │              │
╘════╧══════════════════════════════════════════╧═════════╧════════════╧══════════════╧══════════════════════╧══════════════╧══════════════════════╧══════════════╧══════════════════════╧════════╧══════════════╛


--------------------------------------------------------------------------------
7. Wavefront
7.1 Wavefront Launch Stats
╒═════════╤══════════════════╤════════╤═════════════════════╤════════╤═════════════════════╤════════╤═════════════════════╤════════════╕
│ Index   │ Metric           │    Avg │ Avg                 │    Min │ Min                 │    Max │ Max                 │ Unit       │
╞═════════╪══════════════════╪════════╪═════════════════════╪════════╪═════════════════════╪════════╪═════════════════════╪════════════╡
│ 7.1.0   │ Grid Size        │ 256.00 │ 131072.0 (51100.0%) │ 256.00 │ 131072.0 (51100.0%) │ 256.00 │ 131072.0 (51100.0%) │ Work items │
├─────────┼──────────────────┼────────┼─────────────────────┼────────┼─────────────────────┼────────┼─────────────────────┼────────────┤
│ 7.1.1   │ Workgroup Size   │  64.00 │ 64.0 (0.0%)         │  64.00 │ 64.0 (0.0%)         │  64.00 │ 64.0 (0.0%)         │ Work items │
├─────────┼──────────────────┼────────┼─────────────────────┼────────┼─────────────────────┼────────┼─────────────────────┼────────────┤
│ 7.1.2   │ Total Wavefronts │   4.00 │ 2048.0 (51100.0%)   │   4.00 │ 2048.0 (51100.0%)   │   4.00 │ 2048.0 (51100.0%)   │ Wavefronts │
╘═════════╧══════════════════╧════════╧═════════════════════╧════════╧═════════════════════╧════════╧═════════════════════╧════════════╛</code></pre>
<p>Note that the comparison workload shows the percentage difference from the baseline. This feature can be used to quickly compare filtered stats to make sure code changes fix known issues.</p>
<h3 id="more-kernel-filtering">More Kernel Filtering</h3>
<p>For this exercise, it is appropriate to filter the <code>omniperf analyze</code> command with the <code>--dispatch 1</code> argument. This <code>--dispatch 1</code> argument filters the data shown to only include the kernel invocation with dispatch ID 1, or the second kernel run during profiling.</p>
<p>However, there is another way to filter kernels that may be more applicable in real use-cases. Typically real codes launch many kernels, and only a few of them take most of the overall kernel runtime. To see a ranking of the top kernels that take up most of the kernel runtime in your code, you can run:</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 --list-kernels</code></pre>
<p>This command will output something like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
Detected Kernels
╒════╤═══════════════════════════════════════════════════╕
│    │ KernelName                                        │
╞════╪═══════════════════════════════════════════════════╡
│  0 │ yax(double*, double*, double*, int, int, double*) │
╘════╧═══════════════════════════════════════════════════╛ </code></pre>
<p>Using Omniperf versions greater than <code>1.0.10</code>, <code>--list-kernels</code> will list all kernels launched by your code, in order of runtime (largest runtime first). The number displayed beside the kernel in the output can be used to filter <code>omniperf analyze</code> commands. <strong>Note that this will display aggregated stats for kernels of the same name</strong>, meaning that the invocations could differ in terms of launch parameters, and vary widely in terms of work completed. This filtering is accomplished with the <code>-k</code> argument:</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 -k 0 --metric 7.1.0 7.1.1 7.1.2</code></pre>
<p>Which should show something like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═══════════════╤══════════════╤══════════════╤════════╤═════╕
│    │ KernelName                               │   Count │       Sum(ns) │     Mean(ns) │   Median(ns) │    Pct │ S   │
╞════╪══════════════════════════════════════════╪═════════╪═══════════════╪══════════════╪══════════════╪════════╪═════╡
│  0 │ yax(double*, double*, double*, int, int, │    2.00 │ 1508098228.00 │ 754049114.00 │ 754049114.00 │ 100.00 │ *   │
│    │  double*)                                │         │               │              │              │        │     │
╘════╧══════════════════════════════════════════╧═════════╧═══════════════╧══════════════╧══════════════╧════════╧═════╛


--------------------------------------------------------------------------------
7. Wavefront
7.1 Wavefront Launch Stats
╒═════════╤══════════════════╤════════╤════════╤════════╤════════════╕
│ Index   │ Metric           │    Avg │    Min │    Max │ Unit       │
╞═════════╪══════════════════╪════════╪════════╪════════╪════════════╡
│ 7.1.0   │ Grid Size        │ 256.00 │ 256.00 │ 256.00 │ Work items │
├─────────┼──────────────────┼────────┼────────┼────────┼────────────┤
│ 7.1.1   │ Workgroup Size   │  64.00 │  64.00 │  64.00 │ Work items │
├─────────┼──────────────────┼────────┼────────┼────────┼────────────┤
│ 7.1.2   │ Total Wavefronts │   4.00 │   4.00 │   4.00 │ Wavefronts │
╘═════════╧══════════════════╧════════╧════════╧════════╧════════════╛</code></pre>
<p>Note that the ‘count’ field in Top Stat is 2 here, where filtering by dispatch ID displays a count of 1, indicating that filtering with <code>-k</code> returns aggregated stats for two kernel invocations in this case. Also note that the “Top Stats” table will still show all the top kernels but the rightmost column titled “S” will have an asterisk beside the kernel for which data is being displayed.</p>
<h3 id="solution-roofline">Solution Roofline</h3>
<p>We’ve demonstrated better performance than problem.cpp in solution.cpp, but could we potentially do better? To answer that we again turn to the roofline model:</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Roofline Legend</th>
<th>Roofline Plot</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise1_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise1_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>These plots were generated with:</p>
<pre><code>omniperf profile -n solution_roof_only --roof-only --kernel-names -- ./solution.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/solution_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>We see that the solution is solidly in the bandwidth-bound regime, but even still there seems to be room for improvement. Further performance improvements will be a topic for later exercises.</p>
<h3 id="roofline-comparison">Roofline Comparison</h3>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Problem Roofline</th>
<th>Solution Roofline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_roofline_fp32.png"/></td>
<td><img src="exercise1_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_roofline_int8_fp16.png"/></td>
<td><img src="exercise1_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>We see that the solution has drastically increased performance over the problem code, as shown by the solution points moving up closer to the line plotted by the bandwidth limit.</p>
<p><strong>Note:</strong> on statically generated roofline images, it is possible for the L1, L2, or HBM points to overlap and hide one another.</p>
<h3 id="summary-and-take-aways">Summary and Take-aways</h3>
<p>Launch parameters should be the first check in optimizing performance, due to the fact that they are usually easy to change, but can have a large performance impact if they aren’t tuned to your workload. It is difficult to predict the optimal launch parameters for any given kernel, so some experimentation may be required to achieve the best performance.</p>
<h2 id="exercise-2-lds-occupancy-limiter">Exercise 2: LDS Occupancy Limiter</h2>
<p>Simple kernel implementing a version of yAx, to demonstrate the downside of allocating a large amount of LDS, and the benefit of using a smaller amount of LDS due to occupancy limits.</p>
<strong>Note:</strong> This exercise was tested on a system with MI210s, on omniperf version <code>1.0.10</code> and ROCm 5.7.0
<details>
<summary>
<h3>
Background: Acronyms and terms used in this exercise
</h3>
</summary>
<ul>
<li>
<strong>Wavefront:</strong> A collection of threads, usually 64.
</li>
<li>
<strong>Workgroup:</strong> A collection of Wavefronts (at least 1), which can be scheduled on a Compute Unit (CU)
</li>
<li>
<strong>LDS:</strong> Local Data Store is Shared Memory that is accessible to the entire workgroup on a Compute Unit (CU)
</li>
<li>
<strong>CU:</strong> The Compute Unit is responsible for executing the User’s kernels
</li>
<li>
<strong>SPI:</strong> Shader Processor Input, also referred to as the Workgroup Manager, is responsible for scheduling workgroups on Compute Units
</li>
<li>
<strong>Occupancy:</strong> A measure of how many wavefronts are executing on the GPU on average through the duration of the kernel
</li>
<li>
<strong>PoP:</strong> Percent of Peak refers to the ratio of an achieved value and a theoretical or actual maximum. In terms of occupancy, it is how many wavefronts on average were on the device divided by how many can fit on the device.
<li>
<strong>yAx:</strong> a vector-matrix-vector product, y<em>A</em>x, where y and x are vectors, and A is a matrix
</li>
<pre><code>      &lt;li&gt;&lt;strong&gt;FP(32/16):&lt;/strong&gt; 32- or 16-bit Floating Point numeric types&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;FLOPs:&lt;/strong&gt; Floating Point Operations Per second&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;HBM:&lt;/strong&gt; High Bandwidth Memory is globally accessible from the GPU, and is a level of memory above the L2 cache&lt;/li&gt;
 &lt;/ul&gt;</code></pre>
</details>
<h3 id="initial-roofline-analysis-1">Initial Roofline Analysis</h3>
<p>In this exercise we’re using a problem code that is slightly different than where we left off in Exercise 1. Regardless, to get started we need to get a roofline by running:</p>
<pre><code>omniperf profile -n problem_roof_only --roof-only --kernel-names -- ./problem.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/problem_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>For convenience, the resulting plots on a representative system are below: | Roofline Type | Roofline Legend | Roofline Plot | |—————|—————————————————-|——————————————————| |FP32 |<img src="exercise1_problem_kernelName_legend.png"/>|<img src="exercise2_problem_roofline_fp32.png"/> | |FP16/INT8 |<img src="exercise1_problem_kernelName_legend.png"/>|<img src="exercise2_problem_roofline_int8_fp16.png"/> |</p>
<p>We see that there looks to be room for improvement here. We’ll use omniperf to see what the current limiters are.</p>
<h3 id="exercise-instructions-1">Exercise Instructions:</h3>
<p>First, we should get an idea of the code’s runtime:</p>
<pre><code>make
./problem.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 140 ms</code></pre>
<p>This problem.cpp uses LDS allocations to move the x vector closer to the compute resources, a common optimization. However, we see that it ends up slower than the previous solution that didn’t use LDS at all. In kernels that request a lot of LDS, it is common to see that the LDS usage limits the occupancy of the kernel. That is, more wavefronts cannot be resident on the device, because all of them need more LDS than is available. We need to confirm this hypothesis, let’s start by running:</p>
<pre><code>omniperf profile -n problem --no-roof -- ./problem.exe</code></pre>
<p>The usage of <code>omniperf profile</code> arguments can be found <a href="https://amdresearch.github.io/omniperf/profiling.html#omniperf-profiling">here</a>, or by running <code>omniperf profile --help</code>.</p>
<p>This <code>omniperf profile</code> command will take a minute or two to run, as omniperf must run your code a few times to collect all the hardware counters.</p>
<blockquote>
<p><strong>Note:</strong> For large scientific codes, it can be useful to profile a small representative workload if possible, as profiling a full run may take prohibitively long.</p>
</blockquote>
<p>Once the profiling run completes, let’s take a look at the occupancy stats related to LDS allocations:</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 --dispatch 1 --metric 2.1.26 6.2.7</code></pre>
<p>The metrics we’re looking at are: - <code>2.1.26</code> Wavefront occupancy – a measure of how many wavefronts, on average, are active on the device - <code>6.2.7</code> SPI: Insufficient CU LDS – indicates whether wavefronts are not able to be scheduled due to insufficient LDS</p>
<p>The SPI section (<code>6.2</code>) generally shows what resources limit occupancy, while Wavefront occupancy (<code>2.1.26</code>) shows how severely occupancy is limited in general. The SPI ‘insufficient’ fields are typically either zero or very large numbers (on the order of 1 million), with large numbers indicating some resource preventing wavefronts from scheduling. If more than one field is nonzero, the relative magnitude of the nonzero fields correspond to how severely the resources are limiting occupancy, but if only one field is nonzero it is difficult to say how severely that field is limiting occupancy.</p>
<p>The output of the <code>omniperf analyze</code> command should look similar to this:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤══════════════╤══════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │      Sum(ns) │     Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪══════════════╪══════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 175427205.00 │ 175427205.00 │ 175427205.00 │ 100.00 │
│    │  double*)                                │         │              │              │              │        │
╘════╧══════════════════════════════════════════╧═════════╧══════════════╧══════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
2. System Speed-of-Light
2.1 Speed-of-Light
╒═════════╤════════════════╤═════════╤════════════╤═════════╤═══════╕
│ Index   │ Metric         │   Value │ Unit       │    Peak │   PoP │
╞═════════╪════════════════╪═════════╪════════════╪═════════╪═══════╡
│ 2.1.26  │ Wave Occupancy │  102.70 │ Wavefronts │ 3328.00 │  3.09 │
╘═════════╧════════════════╧═════════╧════════════╧═════════╧═══════╛


--------------------------------------------------------------------------------
6. Shader Processor Input (SPI)
6.2 SPI Resource Allocation
╒═════════╤═════════════════════╤═══════════════╤═══════════════╤═══════════════╤════════╕
│ Index   │ Metric              │           Avg │           Min │           Max │ Unit   │
╞═════════╪═════════════════════╪═══════════════╪═══════════════╪═══════════════╪════════╡
│ 6.2.7   │ Insufficient CU LDS │ 6015745446.00 │ 6015745446.00 │ 6015745446.00 │ Cu     │
╘═════════╧═════════════════════╧═══════════════╧═══════════════╧═══════════════╧════════╛</code></pre>
<p>Looking through this data we see: - Wavefront occupancy (<code>2.1.26</code>) is 3%, which is very low - Insufficient CU LDS (<code>6.2.7</code>) contains a very large number, which indicates our occupancy is currently limited by LDS allocations.</p>
<p>There are two solution directories, which correspond to two ways that this occupancy limit can be addressed. First, we have <code>solution-no-lds</code>, which completely removes the LDS usage. Let’s build and run this solution:</p>
<pre><code>cd solution-no-lds
make
./solution.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 70 ms</code></pre>
<p>We see that the runtime is much better for this solution than the problem, let’s see if removing LDS did indeed increase occupancy:</p>
<pre><code>omniperf profile -n solution --no-roof -- ./solution.exe</code></pre>
<p>(<em>output omitted</em>)</p>
<p>Once the profile command completes, run:</p>
<pre><code>omniperf analyze -p workloads/solution/mi200 --dispatch 1 --metric 2.1.26 6.2.7</code></pre>
<p>The output should look something like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 70512671.00 │ 70512671.00 │  70512671.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
2. System Speed-of-Light
2.1 Speed-of-Light
╒═════════╤════════════════╤═════════╤════════════╤═════════╤═══════╕
│ Index   │ Metric         │   Value │ Unit       │    Peak │   PoP │
╞═════════╪════════════════╪═════════╪════════════╪═════════╪═══════╡
│ 2.1.26  │ Wave Occupancy │  445.33 │ Wavefronts │ 3328.00 │ 13.38 │
╘═════════╧════════════════╧═════════╧════════════╧═════════╧═══════╛


--------------------------------------------------------------------------------
6. Shader Processor Input (SPI)
6.2 SPI Resource Allocation
╒═════════╤═════════════════════╤═══════╤═══════╤═══════╤════════╕
│ Index   │ Metric              │   Avg │   Min │   Max │ Unit   │
╞═════════╪═════════════════════╪═══════╪═══════╪═══════╪════════╡
│ 6.2.7   │ Insufficient CU LDS │  0.00 │  0.00 │  0.00 │ Cu     │
╘═════════╧═════════════════════╧═══════╧═══════╧═══════╧════════╛</code></pre>
<p>Looking through this data we see: - Wave occupancy (<code>2.1.26</code>) is 10% higher than in problem.cpp - Insufficient CU LDS (<code>6.2.7</code>) is now zero, indicating solution-no-lds is not occupancy limited by LDS allocations.</p>
<p>Can we get some runtime advantage from using smaller LDS allocations?</p>
<p>This is the solution implemented in the <code>solution</code> directory:</p>
<pre><code>cd ../solution
make
./solution.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 50 ms</code></pre>
<p>This solution, rather than removing the LDS allocation, simply reduces the amount of LDS requested to address the occupancy limit. This gives us the benefit of having some data pulled closer than it was in <code>solution-no-lds</code> which is validated through the speedup we see. But is this solution still occupancy limited by LDS?</p>
<pre><code>omniperf profile -n solution --no-roof -- ./solution.exe</code></pre>
<p>(<em>output omitted</em>)</p>
<p>Once the profile command completes, run:</p>
<pre><code>omniperf analyze -p workloads/solution/mi200 --dispatch 1 --metric 2.1.26 6.2.7</code></pre>
<p>The output should look something like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 50366185.00 │ 50366185.00 │  50366185.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
2. System Speed-of-Light
2.1 Speed-of-Light
╒═════════╤════════════════╤═════════╤════════════╤═════════╤═══════╕
│ Index   │ Metric         │   Value │ Unit       │    Peak │   PoP │
╞═════════╪════════════════╪═════════╪════════════╪═════════╪═══════╡
│ 2.1.26  │ Wave Occupancy │  487.32 │ Wavefronts │ 3328.00 │ 14.64 │
╘═════════╧════════════════╧═════════╧════════════╧═════════╧═══════╛


--------------------------------------------------------------------------------
6. Shader Processor Input (SPI)
6.2 SPI Resource Allocation
╒═════════╤═════════════════════╤═══════╤═══════╤═══════╤════════╕
│ Index   │ Metric              │   Avg │   Min │   Max │ Unit   │
╞═════════╪═════════════════════╪═══════╪═══════╪═══════╪════════╡
│ 6.2.7   │ Insufficient CU LDS │  0.00 │  0.00 │  0.00 │ Cu     │
╘═════════╧═════════════════════╧═══════╧═══════╧═══════╧════════╛</code></pre>
<p>Looking at this data we see: - Wave Occupancy (<code>2.1.26</code>) is even higher than before - Insufficient CU LDS (<code>6.2.7</code>) shows we are not occupancy limited by LDS allocations.</p>
<p>Pulling some data from global device memory to LDS can be an effective optimization strategy, if occupancy limits are carefully avoided.</p>
<h3 id="solution-roofline-1">Solution Roofline</h3>
<p>Let’s take a look at the roofline for <code>solution</code>, which can be generated with:</p>
<pre><code>omniperf profile -n solution_roof_only --roof-only -- ./solution.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/problem_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>The plots are shown here: | Roofline Type | Roofline Legend | Roofline Plot | |—————|—————————————————-|——————————————————| |FP32 |<img src="exercise1_problem_kernelName_legend.png"/>|<img src="exercise2_solution_roofline_fp32.png"/> | |FP16/INT8 |<img src="exercise1_problem_kernelName_legend.png"/>|<img src="exercise2_solution_roofline_int8_fp16.png"/> |</p>
<p>We see that there is still room to move the solution roofline up towards the bandwidth limit.</p>
<h3 id="roofline-comparison-1">Roofline Comparison</h3>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Problem Roofline</th>
<th>Solution Roofline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise2_problem_roofline_fp32.png"/></td>
<td><img src="exercise2_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise2_problem_roofline_int8_fp16.png"/></td>
<td><img src="exercise2_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>Again, we see that the solution’s optimizations have resulted in the kernel moving up in the roofline, meaning the solution executes more efficiently than the problem.</p>
<h3 id="summary-and-take-aways-1">Summary and Take-aways</h3>
<p>Using LDS can be very helpful in reducing global memory reads where you have repeated use of the same data. However, large LDS allocations can also negatively impact performance by limiting the amount of wavefronts that can be resident in the device at any given time. Be wary of LDS usage, and check the SPI stats to ensure your LDS usage is not negatively impacting occupancy.</p>
<h2 id="exercise-3-register-occupancy-limiter">Exercise 3: Register Occupancy Limiter</h2>
<p>More complex yAx implementation to demonstrate a register limited kernel using an innocuous looking function call.</p>
<strong>Note:</strong> This exercise was tested on a system with MI210s, on omniperf version <code>1.0.10</code> and ROCm 5.7.0
<details>
<summary>
<h3>
Background: Acronyms and terms used in this exercise
</h3>
</summary>
<ul>
<li>
<strong>VGPR:</strong> Vector General Purpose Register, holds distinct values for each thread in a wavefront
</li>
<li>
<strong>SGPR:</strong> Scalar General Purpose Register, holds a single value for all threads in a workgroup
</li>
<li>
<strong>AGPR:</strong> Accumulation vector General Purpose Register, used for Matrix Fused Multiply-Add (MFMA) instructions, or low-cost register spills
</li>
<li>
<strong>Wavefront:</strong> A collection of threads, usually 64.
</li>
<li>
<strong>Workgroup:</strong> A collection of Wavefronts (at least 1), which can be scheduled on a Compute Unit (CU)
</li>
<li>
<strong>LDS:</strong> Local Data Store is Shared Memory that is accessible to the entire workgroup on a Compute Unit (CU)
</li>
<li>
<strong>CU:</strong> The Compute Unit is responsible for executing the User’s kernels
</li>
<li>
<strong>SPI:</strong> Shader Processor Input, also referred to as the Workgroup Manager, is responsible for scheduling workgroups on Compute Units
</li>
<li>
<strong>Occupancy:</strong> A measure of how many wavefronts are executing on the GPU on average through the duration of the kernel
</li>
<li>
<strong>PoP:</strong> Percent of Peak refers to the ratio of an achieved value and a theoretical or actual maximum. In terms of occupancy, it is how many wavefronts on average were on the device divided by how many can fit on the device.
<li>
<strong>yAx:</strong> a vector-matrix-vector product, y<em>A</em>x, where y and x are vectors, and A is a matrix
</li>
<pre><code>      &lt;li&gt;&lt;strong&gt;FP(32/16):&lt;/strong&gt; 32- or 16-bit Floating Point numeric types&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;FLOPs:&lt;/strong&gt; Floating Point Operations Per second&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;HBM:&lt;/strong&gt; High Bandwidth Memory is globally accessible from the GPU, and is a level of memory above the L2 cache&lt;/li&gt;
 &lt;/ul&gt;</code></pre>
</details>
<h3 id="initial-roofline-analysis-2">Initial Roofline Analysis</h3>
<p>This kernel is slightly different from the one we used in previous exercises. Let’s see how well it measures up in the roofline:</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Roofline Legend</th>
<th>Roofline Plot</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise3_problem_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise3_problem_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>You can generate these plots by running:</p>
<pre><code>omniperf profile -n problem_roof_only --roof-only --kernel-names -- ./problem.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/problem_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>We see that the kernel is still a considerable amount below the maximum achievable bandwidth, so there should still be room for improvement.</p>
<h3 id="exercise-instructions-2">Exercise Instructions:</h3>
<p>Let’s get an idea of the runtime of this code:</p>
<pre><code>make
./problem.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time 79 ms</code></pre>
<p>We see that this kernel seems to be on par with some of our other exercises, but let’s see what omniperf shows us:</p>
<pre><code>omniperf profile -n problem --no-roof -- ./problem.exe</code></pre>
<p>(<em>lots of output from this command</em>)</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 --dispatch 1 --metric 2.1.26 6.2.5 7.1.5 7.1.6 7.1.7</code></pre>
<ul>
<li><code>2.1.26</code> Shows Wavefront occupancy</li>
<li><code>6.2.5</code> Shows Insufficient SIMD VGPRs – indicating if this kernel is occupancy limited by VGPR usage</li>
<li><code>7.1.5-7</code> Shows the register usage: VGPRs, SGPRs, and AGPRs</li>
</ul>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 76983902.00 │ 76983902.00 │  76983902.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
2. System Speed-of-Light
2.1 Speed-of-Light
╒═════════╤════════════════╤═════════╤════════════╤═════════╤═══════╕
│ Index   │ Metric         │   Value │ Unit       │    Peak │   PoP │
╞═════════╪════════════════╪═════════╪════════════╪═════════╪═══════╡
│ 2.1.26  │ Wave Occupancy │  438.00 │ Wavefronts │ 3328.00 │ 13.16 │
╘═════════╧════════════════╧═════════╧════════════╧═════════╧═══════╛


--------------------------------------------------------------------------------
6. Shader Processor Input (SPI)
6.2 SPI Resource Allocation
╒═════════╤═════════════════════════╤═════════════╤═════════════╤═════════════╤════════╕
│ Index   │ Metric                  │         Avg │         Min │         Max │ Unit   │
╞═════════╪═════════════════════════╪═════════════╪═════════════╪═════════════╪════════╡
│ 6.2.5   │ Insufficient SIMD VGPRs │ 13733460.00 │ 13733460.00 │ 13733460.00 │ Simd   │
╘═════════╧═════════════════════════╧═════════════╧═════════════╧═════════════╧════════╛


--------------------------------------------------------------------------------
7. Wavefront
7.1 Wavefront Launch Stats
╒═════════╤══════════╤════════╤════════╤════════╤═══════════╕
│ Index   │ Metric   │    Avg │    Min │    Max │ Unit      │
╞═════════╪══════════╪════════╪════════╪════════╪═══════════╡
│ 7.1.5   │ VGPRs    │  92.00 │  92.00 │  92.00 │ Registers │
├─────────┼──────────┼────────┼────────┼────────┼───────────┤
│ 7.1.6   │ AGPRs    │ 132.00 │ 132.00 │ 132.00 │ Registers │
├─────────┼──────────┼────────┼────────┼────────┼───────────┤
│ 7.1.7   │ SGPRs    │  48.00 │  48.00 │  48.00 │ Registers │
╘═════════╧══════════╧════════╧════════╧════════╧═══════════╛</code></pre>
<p>Looking at this data, we see: - Insufficient SIMD VGPRs (<code>6.2.5</code>) shows a large number (on the order of 10 million), which indicates our kernel is occupancy limited by VGPR register usage. - VGPRs (<code>7.1.5</code>) shows we are using a lot of VGPRs and AGPRs (<code>7.1.6</code>) shows we are using a lot of AGPRs, which can indicate low-cost register spills in the absence of MFMA instructions.</p>
<p>This is due to a call to <code>assert</code> that checks if our result is zeroed out on device. We need to check this hypothesis, let’s look at the solution code:</p>
<pre><code>cd solution
make
./solution.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 70 ms</code></pre>
<p>Our runtime gets better from removing the <code>assert</code>, but we should also check that omniperf reports that our limiters are gone:</p>
<pre><code>omniperf profile -n solution --no-roof -- ./solution.exe</code></pre>
<p>(<em>omitted output</em>)</p>
<pre><code>omniperf analyze -p workloads/solution/mi200 --dispatch 1 --metric 2.1.26 6.2.5 7.1.5 7.1.6 7.1.7</code></pre>
<p>The output of this command should look something like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 69815871.00 │ 69815871.00 │  69815871.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
2. System Speed-of-Light
2.1 Speed-of-Light
╒═════════╤════════════════╤═════════╤════════════╤═════════╤═══════╕
│ Index   │ Metric         │   Value │ Unit       │    Peak │   PoP │
╞═════════╪════════════════╪═════════╪════════════╪═════════╪═══════╡
│ 2.1.26  │ Wave Occupancy │  444.10 │ Wavefronts │ 3328.00 │ 13.34 │
╘═════════╧════════════════╧═════════╧════════════╧═════════╧═══════╛


--------------------------------------------------------------------------------
6. Shader Processor Input (SPI)
6.2 SPI Resource Allocation
╒═════════╤═════════════════════════╤═══════╤═══════╤═══════╤════════╕
│ Index   │ Metric                  │   Avg │   Min │   Max │ Unit   │
╞═════════╪═════════════════════════╪═══════╪═══════╪═══════╪════════╡
│ 6.2.5   │ Insufficient SIMD VGPRs │  0.00 │  0.00 │  0.00 │ Simd   │
╘═════════╧═════════════════════════╧═══════╧═══════╧═══════╧════════╛


--------------------------------------------------------------------------------
7. Wavefront
7.1 Wavefront Launch Stats
╒═════════╤══════════╤═══════╤═══════╤═══════╤═══════════╕
│ Index   │ Metric   │   Avg │   Min │   Max │ Unit      │
╞═════════╪══════════╪═══════╪═══════╪═══════╪═══════════╡
│ 7.1.5   │ VGPRs    │ 32.00 │ 32.00 │ 32.00 │ Registers │
├─────────┼──────────┼───────┼───────┼───────┼───────────┤
│ 7.1.6   │ AGPRs    │  0.00 │  0.00 │  0.00 │ Registers │
├─────────┼──────────┼───────┼───────┼───────┼───────────┤
│ 7.1.7   │ SGPRs    │ 96.00 │ 96.00 │ 96.00 │ Registers │
╘═════════╧══════════╧═══════╧═══════╧═══════╧═══════════╛</code></pre>
<p>Looking at this data, we see: - Insufficient SIMD VGPRs (<code>6.2.5</code>) shows we are no longer occupancy limited by VGPR usage. - VGPRs (<code>7.1.5</code>) and AGPRs (<code>7.1.6</code>) show considerably fewer vector registers, and no AGPRs being used. - SGPRs (<code>7.1.7</code>) shows a 2x increase over the previous implementation, which shows our memory access is more uniform here. - Wave Occupancy (<code>2.1.26</code>) shows our occupancy increased only slightly from the previous implementation, despite the large decrease in <code>6.2.5</code>.</p>
<p>More generally, you can use this command to look at all SPI “insufficient resource” stats in the same screen, to determine if any resource is currently limiting occupancy:</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 --dispatch 1 --metric 6.2</code></pre>
<p>Which will show output similar to this (note, fields <code>6.2.4</code> to <code>6.2.9</code> show resources which currently limit occupancy):</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 76983902.00 │ 76983902.00 │  76983902.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
6. Shader Processor Input (SPI)
6.2 SPI Resource Allocation
╒═════════╤═════════════════════════════╤═════════════╤═════════════╤═════════════╤═════════════╕
│ Index   │ Metric                      │         Avg │         Min │         Max │ Unit        │
╞═════════╪═════════════════════════════╪═════════════╪═════════════╪═════════════╪═════════════╡
│ 6.2.0   │ Wave request Failed (CS)    │   480983.00 │   480983.00 │   480983.00 │ Cycles      │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.1   │ CS Stall                    │   280093.00 │   280093.00 │   280093.00 │ Cycles      │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.2   │ CS Stall Rate               │        0.22 │        0.22 │        0.22 │ Pct         │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.3   │ Scratch Stall               │        0.00 │        0.00 │        0.00 │ Cycles      │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.4   │ Insufficient SIMD Waveslots │        0.00 │        0.00 │        0.00 │ Simd        │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.5   │ Insufficient SIMD VGPRs     │ 13733460.00 │ 13733460.00 │ 13733460.00 │ Simd        │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.6   │ Insufficient SIMD SGPRs     │        0.00 │        0.00 │        0.00 │ Simd        │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.7   │ Insufficient CU LDS         │        0.00 │        0.00 │        0.00 │ Cu          │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.8   │ Insufficient CU Barries     │        0.00 │        0.00 │        0.00 │ Cu          │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.9   │ Insufficient Bulky Resource │        0.00 │        0.00 │        0.00 │ Cu          │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.10  │ Reach CU Threadgroups Limit │        0.00 │        0.00 │        0.00 │ Cycles      │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.11  │ Reach CU Wave Limit         │        0.00 │        0.00 │        0.00 │ Cycles      │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.12  │ VGPR Writes                 │        4.00 │        4.00 │        4.00 │ Cycles/wave │
├─────────┼─────────────────────────────┼─────────────┼─────────────┼─────────────┼─────────────┤
│ 6.2.13  │ SGPR Writes                 │        3.00 │        3.00 │        3.00 │ Cycles/wave │
╘═════════╧═════════════════════════════╧═════════════╧═════════════╧═════════════╧═════════════╛</code></pre>
<h3 id="solution-roofline-2">Solution Roofline</h3>
<p>Let’s see how the solution stacks up in the roofline:</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Roofline Legend</th>
<th>Roofline Plot</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise3_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise3_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>You can generate these plots with:</p>
<pre><code>omniperf profile -n problem_roof_only --roof-only --kernel-names -- ./problem.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/problem_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>We see there is still room for improvement in the solution, as this kernel is not getting the maximum achievable bandwidth.</p>
<h3 id="roofline-comparison-2">Roofline Comparison</h3>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Problem Roofline</th>
<th>Solution Roofline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise3_problem_roofline_fp32.png"/></td>
<td><img src="exercise3_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise3_problem_roofline_int8_fp16.png"/></td>
<td><img src="exercise3_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>The most notable change between these rooflines is that the L1/L2 arithmetic intensity spread is more pronounced in the problem, which shows that the call to <code>assert</code> was causing more data to be moved to the L1, while not adding floating-point operations.</p>
<p><strong>Note:</strong> Arithmetic Intensity is computed as <code>(total floating point operations)/(total data movement)</code></p>
<h3 id="summary-and-take-aways-2">Summary and Take-aways</h3>
<p>Function calls inside kernels can have surprisingly adverse performance side-effects. Calling assert, printf and even excessive use of math functions (e.g. pow, sin, cos) can limit performance in difficult-to-predict ways. If you see unexpected resource usage, try eliminating these sorts of function calls.</p>
<h2 id="exercise-4-strided-data-access-patterns-and-how-to-find-them">Exercise 4: Strided Data Access Patterns (and how to find them)</h2>
<p>This exercise uses a simple implementation of a yAx kernel to show how difficult strided data access patterns can be to spot in code, and demonstrates how to use omniperf to begin to diagnose them.</p>
<p><strong>Note:</strong> This exercise was tested on a system with MI210s, on omniperf version <code>1.0.10</code> and ROCm 5.7.0</p>
<details>
<summary>
<h3>
Background: Acronyms and terms used in this exercise
</h3>
</summary>
<ul>
<li>
<strong>L1:</strong> Level 1 Cache, the first level cache local to the Compute Unit (CU). If requested data is not found in the L1, the request goes to the L2
</li>
<li>
<strong>L2:</strong> Level 2 Cache, the second level cache, which is shared by all Compute Units (CUs) on a GPU. If requested data is not found in the L2, the request goes to HBM
</li>
<li>
<strong>HBM:</strong> High Bandwidth Memory is globally accessible from the GPU, and is a level of memory above the L2 cache
</li>
<li>
<strong>CU:</strong> The Compute Unit is responsible for executing the User’s kernels
</li>
<li>
<strong>yAx:</strong> a vector-matrix-vector product, y<em>A</em>x, where y and x are vectors, and A is a matrix
</li>
<li>
<strong>FP(32/16):</strong> 32- or 16-bit Floating Point numeric types
</li>
</ul>
</details>
<details>
<summary>
<h3>
Background: What is a “Strided Data Access Pattern”?
</h3>
</summary> Strided data patterns happen when each thread in a wavefront has to access data locations which have a lot of space between them. For instance, in the algorithm we’ve been using, each thread works on a row, and those rows are contiguous in device memory. This scenario is depicted below: <img src="striding.PNG"/> Here the memory addresses accessed by threads at each step of the computation have a lot of space between them, which is suboptimal for memory systems, especially on GPUs. To fix this, we have to re-structure the matrix A so that the columns of the matrix are contiguous, which will result in the rows striding, as seen below: <img src="no_stride.PNG"/> This new data layout has each block of threads accessing a contiguous chunk of device memory, and will use the memory system of the device much more efficiently. Importantly, the only thing that changed is the physical layout of the memory, so the result of this computation will be the same as the result of the previous data layout.
</details>
<h3 id="initial-roofline-analysis-3">Initial Roofline Analysis</h3>
<p>To start, we want to check the roofline of <code>problem.exe</code>, to make sure we are able to improve it. These plots can be generated with:</p>
<pre><code>omniperf profile -n problem_roof_only --roof-only --kernel-names -- ./problem.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/problem_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>They are also provided below for easy reference:</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Roofline Legend</th>
<th>Roofline Plot</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise4_problem_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise4_problem_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>We have plenty of space to improve this kernel, the next step is profiling.</p>
<h3 id="exercise-instructions-3">Exercise Instructions:</h3>
<p>To start, let’s build and run the problem executable:</p>
<pre><code>make
./problem.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 70 ms</code></pre>
<p>From our other experiments, this time seems reasonable. Let’s look closer at the memory system usage with omniperf:</p>
<pre><code>omniperf profile -n problem --no-roof -- ./problem.exe</code></pre>
<p>(<em>omitted output</em>)</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 --dispatch 1 --metric 16.1 17.1</code></pre>
<blockquote>
<p>Previous examples have used specific fields inside metrics, but we can also request a group of metrics with just two numbers (i.e. 16.1 vs. 16.1.1)</p>
</blockquote>
<p>These requested metrics are: - <code>16.1</code> L1 memory speed-of-light stats - <code>17.1</code> L2 memory speed-of-light stats</p>
<p>The speed-of-light stats are a more broad overview of how the memory systems are used throughout execution of your kernel. As such, they’re great statistics for seeing if the memory system is generally being used efficiently or not. Output from the <code>analyze</code> command should look like this:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 69768072.00 │ 69768072.00 │  69768072.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
16. Vector L1 Data Cache
16.1 Speed-of-Light
╒═════════╤═══════════════════╤═════════╤═════════════╕
│ Index   │ Metric            │   Value │ Unit        │
╞═════════╪═══════════════════╪═════════╪═════════════╡
│ 16.1.0  │ Buffer Coalescing │   25.00 │ Pct of peak │
├─────────┼───────────────────┼─────────┼─────────────┤
│ 16.1.1  │ Cache Util        │   87.79 │ Pct of peak │
├─────────┼───────────────────┼─────────┼─────────────┤
│ 16.1.2  │ Cache BW          │    8.71 │ Pct of peak │
├─────────┼───────────────────┼─────────┼─────────────┤
│ 16.1.3  │ Cache Hit         │    0.00 │ Pct of peak │
╘═════════╧═══════════════════╧═════════╧═════════════╛


--------------------------------------------------------------------------------
17. L2 Cache
17.1 Speed-of-Light
╒═════════╤═════════════╤═════════╤════════╕
│ Index   │ Metric      │   Value │ Unit   │
╞═════════╪═════════════╪═════════╪════════╡
│ 17.1.0  │ L2 Util     │   98.72 │ Pct    │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.1  │ Cache Hit   │   93.46 │ Pct    │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.2  │ L2-EA Rd BW │  125.87 │ Gb/s   │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.3  │ L2-EA Wr BW │    0.00 │ Gb/s   │
╘═════════╧═════════════╧═════════╧════════╛</code></pre>
<p>Looking at this data, we see: - L1 Cache Hit (<code>16.1.3</code>) is 0%, so the kernel’s memory requests are never found in the L1. - L2 Cache Hit (<code>17.1.1</code>) is 93.46%, so most requests are found in the L2, with about 7% needing to go out to HBM. - We are never finding data in the L1 and generating a lot of requests to the L2, so restructuring our data accesses should provide better performance</p>
<p>Since our implementation of yAx simply uses 1 for all values in y, A, and x, we do not have to change how we populate our data. Since A is implemented as a flat array, we don’t need to change our allocation either. &gt;In real-world use-cases, these considerations add non-trivial development overhead, so data access patterns may be non-trivial to change.</p>
<p>To observe the performance effects of a different data access pattern, we simply need to change our indexing scheme. Let’s see how this performs by running <code>solution</code>:</p>
<pre><code>cd solution
make
./solution.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 12 ms</code></pre>
<p>We see the runtime here is significantly better than our previous kernel, but we need to check how the caches behave now:</p>
<pre><code>omniperf profile -n solution --no-roof -- ./solution.exe</code></pre>
<p>(<em>output omitted</em>)</p>
<pre><code>omniperf analyze -p workloads/solution/mi200 --dispatch 1 --metric 16.1 17.1</code></pre>
<p>The output from this analyze command should look like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 12464570.00 │ 12464570.00 │  12464570.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
16. Vector L1 Data Cache
16.1 Speed-of-Light
╒═════════╤═══════════════════╤═════════╤═════════════╕
│ Index   │ Metric            │   Value │ Unit        │
╞═════════╪═══════════════════╪═════════╪═════════════╡
│ 16.1.0  │ Buffer Coalescing │   25.00 │ Pct of peak │
├─────────┼───────────────────┼─────────┼─────────────┤
│ 16.1.1  │ Cache Util        │   97.99 │ Pct of peak │
├─────────┼───────────────────┼─────────┼─────────────┤
│ 16.1.2  │ Cache BW          │   12.19 │ Pct of peak │
├─────────┼───────────────────┼─────────┼─────────────┤
│ 16.1.3  │ Cache Hit         │   49.98 │ Pct of peak │
╘═════════╧═══════════════════╧═════════╧═════════════╛


--------------------------------------------------------------------------------
17. L2 Cache
17.1 Speed-of-Light
╒═════════╤═════════════╤═════════╤════════╕
│ Index   │ Metric      │   Value │ Unit   │
╞═════════╪═════════════╪═════════╪════════╡
│ 17.1.0  │ L2 Util     │   98.67 │ Pct    │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.1  │ Cache Hit   │    0.52 │ Pct    │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.2  │ L2-EA Rd BW │  689.26 │ Gb/s   │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.3  │ L2-EA Wr BW │    0.00 │ Gb/s   │
╘═════════╧═════════════╧═════════╧════════╛</code></pre>
<p>Looking at this data, we see: - L1 Cache Hit (<code>16.1.3</code>) is around 50%, so half the requests to the L1 need to go to the L2. - L2 Cache Hit (<code>17.1.1</code>) is 0.52%, so almost all the requests to the L2 have to go out to HBM. - L2-EA Rd BW (<code>17.1.2</code>) has increased significantly, due to the increase in L2 cache misses requiring HBM reads.</p>
<h3 id="solution-roofline-analysis">Solution Roofline Analysis</h3>
<p>We should check where our new kernel stands on the roofline. These plots can be generated with:</p>
<pre><code>omniperf profile -n solution_roof_only --roof-only --kernel-names -- ./solution.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/problem_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>They are also provided below for easy reference:</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Roofline Legend</th>
<th>Roofline Plot</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise4_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise4_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>We appear to be very close to being bound by the HBM bandwidth from the fp32 roofline. To get more performance we need to look closer at our algorithm.</p>
<h3 id="roofline-comparison-3">Roofline Comparison</h3>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Problem Roofline</th>
<th>Solution Roofline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise4_problem_roofline_fp32.png"/></td>
<td><img src="exercise4_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise4_problem_roofline_int8_fp16.png"/></td>
<td><img src="exercise4_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>We see that the HBM roofline point moves up, while the L1/L2 points move up and to the right from problem to solution. This means that our arithmetic intensity is increasing for the caches, so we are moving less data through the caches to do the same computation.</p>
<h3 id="summary-and-take-aways-3">Summary and Take-aways</h3>
<p>This exercise illustrates the at times insidious nature of strided data access patterns. They can be difficult to spot in code, but profiling more readily shows when adversarial access patterns occur, by showing poor cache hit rates, low cache bandwidth, and potentially low utilization. Data access patterns can be non-trivial to change, so these sorts of optimizations can involve significant development and validation overhead.</p>
<h2 id="exercise-5-algorithmic-optimizations">Exercise 5: Algorithmic Optimizations</h2>
<p>A simple yAx kernel, and more efficient, but more complex yAx kernel to demonstrate algorithmic improvements.</p>
<p><strong>Note:</strong> This exercise was tested on a system with MI210s, on omniperf version <code>1.0.10</code> and ROCm 5.7.0</p>
<details>
<summary>
<h3>
Background: Acronyms and terms used in this exercise
</h3>
</summary>
<ul>
<li>
<strong>L1:</strong> Level 1 Cache, the first level cache local to the Compute Unit (CU). If requested data is not found in the L1, the request goes to the L2
</li>
<li>
<strong>L2:</strong> Level 2 Cache, the second level cache, which is shared by all Compute Units (CUs) on a GPU. If requested data is not found in the L2, the request goes to HBM
</li>
<li>
<strong>HBM:</strong> High Bandwidth Memory is globally accessible from the GPU, and is a level of memory above the L2 cache
</li>
<li>
<strong>CU:</strong> The Compute Unit is responsible for executing the User’s kernels
</li>
<li>
<strong>yAx:</strong> a vector-matrix-vector product, y<em>A</em>x, where y and x are vectors, and A is a matrix
</li>
<li>
<strong>FP(32/16):</strong> 32- or 16-bit Floating Point numeric types
</li>
</ul>
</details>
<details>
<summary>
<h3>
Background: yAx Algorithmic Improvement Explanation
</h3>
</summary> Our approach up to this point could be described as having each thread sum up a row, as illustrated below: <img src="threadrows.PNG"/> However, this is not efficient in the way the parallelism is expressed. Namely, we could add up all the partial sums for each row in parallel. This would make our approach to be: give a rows to wavefronts, and have the threads inside each wavefront sum up partial sums in parallel. Then, we reduce the partial sums atomically with shared memory, before completing the computation and reducing the final answer using global atomics. This approach expresses more of the parallelism that is available, and would look something like the figure below: <img src="wavefrontrow.PNG"/> The expressed parallelism in each approach roughly corresponds to the number of red arrows in each figure.
</details>
<h3 id="initial-roofline-analysis-4">Initial Roofline Analysis</h3>
<p>We should start by doing a roofline to see where the problem executable stands. These plots can be generated with:</p>
<pre><code>omniperf profile -n problem_roof_only --roof-only --kernel-names -- ./problem.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/problem_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>They are also provided below for easy reference:</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Roofline Legend</th>
<th>Roofline Plot</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise5_problem_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise5_problem_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>The performance of this kernel looks pretty close to being HBM bandwidth bound. In the case of algorithmic optimizations, there may not be obvious evidence other than a suspicion that poor usage of hardware resources may be improved by changing the overall approach. In this case, we should be able to make better usage of both L1 and L2 resources by using wavefronts more efficiently to better parallelize our computation.</p>
<h3 id="exercise-instructions-4">Exercise Instructions:</h3>
<p>To start, let’s profile <code>problem.exe</code>:</p>
<pre><code>make
./problem.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time 12 ms</code></pre>
<p>This should be in line with our last solution. From the last exercise, we saw this output from <code>omniperf analyze</code> for this kernel:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 12427547.00 │ 12427547.00 │  12427547.00 │ 100.00 │
│    │  double*) [clone .kd]                    │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
16. Vector L1 Data Cache
16.1 Speed-of-Light
╒═════════╤═══════════════════╤═════════╕
│ Index   │ Metric            │   Value │
╞═════════╪═══════════════════╪═════════╡
│ 16.1.0  │ Buffer Coalescing │   25.00 │
├─────────┼───────────────────┼─────────┤
│ 16.1.1  │ Cache Util        │   98.19 │
├─────────┼───────────────────┼─────────┤
│ 16.1.2  │ Cache BW          │   12.22 │
├─────────┼───────────────────┼─────────┤
│ 16.1.3  │ Cache Hit         │   49.98 │
╘═════════╧═══════════════════╧═════════╛


--------------------------------------------------------------------------------
17. L2 Cache
17.1 Speed-of-Light
╒═════════╤═════════════╤═════════╤════════╕
│ Index   │ Metric      │   Value │ Unit   │
╞═════════╪═════════════╪═════════╪════════╡
│ 17.1.0  │ L2 Util     │   98.45 │ Pct    │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.1  │ Cache Hit   │    0.52 │ Pct    │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.2  │ L2-EA Rd BW │  691.32 │ Gb/s   │
├─────────┼─────────────┼─────────┼────────┤
│ 17.1.3  │ L2-EA Wr BW │    0.00 │ Gb/s   │
╘═════════╧═════════════╧═════════╧════════╛</code></pre>
<p>Looking at this data again, we see: - L1 Cache Hit (<code>16.1.3</code>) is about 50%, which is fairly low for a “well performing” kernel. - L2 Cache Hit (<code>17.1.1</code>) is about 0%, which is very low to consider this kernel “well performing”.</p>
<p>Let’s run the profiling again, but dig more into detailed L1 and L2 stats to see if we can make better use of the L1 and L2:</p>
<pre><code>omniperf profile -n problem --no-roof -- ./problem.exe</code></pre>
<p>(<em>output omitted</em>)</p>
<pre><code>omniperf analyze -p workloads/problem/mi200 --dispatch 1 --metric 16.3 16.4 17.3 17.2</code></pre>
<p>The metrics we request are: - <code>16.3</code> Detailed L1 cache access stats - <code>16.4</code> Detailed L1-L2 transaction stats - <code>17.3</code> Detailed L2 access stats - <code>17.2</code> Detailed L2-Fabric transaction stats</p>
<p>The output from the <code>analyze</code> command should look something like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═════════════╤═════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │     Sum(ns) │    Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═════════════╪═════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 12392886.00 │ 12392886.00 │  12392886.00 │ 100.00 │
│    │  double*)                                │         │             │             │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═════════════╧═════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
16. Vector L1 Data Cache
16.3 L1D Cache Accesses
╒═════════╤═════════════════════╤════════════╤════════════╤════════════╤════════════════╕
│ Index   │ Metric              │        Avg │        Min │        Max │ Unit           │
╞═════════╪═════════════════════╪════════════╪════════════╪════════════╪════════════════╡
│ 16.3.0  │ Total Req           │  524368.00 │  524368.00 │  524368.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.1  │ Read Req            │  524304.00 │  524304.00 │  524304.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.2  │ Write Req           │       0.00 │       0.00 │       0.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.3  │ Atomic Req          │      64.00 │      64.00 │      64.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.4  │ Cache BW            │    1386.99 │    1386.99 │    1386.99 │ Gb/s           │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.5  │ Cache Accesses      │  131140.00 │  131140.00 │  131140.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.6  │ Cache Hits          │   65538.00 │   65538.00 │   65538.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.7  │ Cache Hit Rate      │      49.98 │      49.98 │      49.98 │ Pct            │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.8  │ Invalidate          │       0.00 │       0.00 │       0.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.9  │ L1-L2 BW            │ 4198528.00 │ 4198528.00 │ 4198528.00 │ Bytes per wave │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.10 │ L1-L2 Read          │   65538.00 │   65538.00 │   65538.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.11 │ L1-L2 Write         │       0.00 │       0.00 │       0.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.12 │ L1-L2 Atomic        │      64.00 │      64.00 │      64.00 │ Req per wave   │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.13 │ L1 Access Latency   │     477.63 │     477.63 │     477.63 │ Cycles         │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.14 │ L1-L2 Read Latency  │     399.51 │     399.51 │     399.51 │ Cycles         │
├─────────┼─────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 16.3.15 │ L1-L2 Write Latency │    5746.67 │    5746.67 │    5746.67 │ Cycles         │
╘═════════╧═════════════════════╧════════════╧════════════╧════════════╧════════════════╛
16.4 L1D - L2 Transactions
╒═════════╤═════════════╤════════╤═════════════╤══════════╤══════════╤══════════╤══════════════╕
│ Index   │ Metric      │ Xfer   │ Coherency   │      Avg │      Min │      Max │ Unit         │
╞═════════╪═════════════╪════════╪═════════════╪══════════╪══════════╪══════════╪══════════════╡
│ 16.4.0  │ NC - Read   │ Read   │ NC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.1  │ UC - Read   │ Read   │ UC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.2  │ CC - Read   │ Read   │ CC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.3  │ RW - Read   │ Read   │ RW          │ 65538.00 │ 65538.00 │ 65538.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.4  │ RW - Write  │ Write  │ RW          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.5  │ NC - Write  │ Write  │ NC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.6  │ UC - Write  │ Write  │ UC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.7  │ CC - Write  │ Write  │ CC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.8  │ NC - Atomic │ Atomic │ NC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.9  │ UC - Atomic │ Atomic │ UC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.10 │ CC - Atomic │ Atomic │ CC          │     0.00 │     0.00 │     0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼──────────┼──────────┼──────────┼──────────────┤
│ 16.4.11 │ RW - Atomic │ Atomic │ RW          │    64.00 │    64.00 │    64.00 │ Req per wave │
╘═════════╧═════════════╧════════╧═════════════╧══════════╧══════════╧══════════╧══════════════╛


--------------------------------------------------------------------------------
17. L2 Cache
17.2 L2 - Fabric Transactions
╒═════════╤══════════════════════╤════════════╤════════════╤════════════╤════════════════╕
│ Index   │ Metric               │ Avg        │ Min        │ Max        │ Unit           │
╞═════════╪══════════════════════╪════════════╪════════════╪════════════╪════════════════╡
│ 17.2.0  │ Read BW              │ 4195055.47 │ 4195055.47 │ 4195055.47 │ Bytes per wave │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.1  │ Write BW             │ 0.14       │ 0.14       │ 0.14       │ Bytes per wave │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.2  │ Read (32B)           │ 0.0        │ 0.0        │ 0.0        │ Req per wave   │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.3  │ Read (Uncached 32B)  │ 0.55       │ 0.55       │ 0.55       │ Req per wave   │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.4  │ Read (64B)           │ 65547.74   │ 65547.74   │ 65547.74   │ Req per wave   │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.5  │ HBM Read             │ 65546.38   │ 65546.38   │ 65546.38   │ Req per wave   │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.6  │ Write (32B)          │ 0.0        │ 0.0        │ 0.0        │ Req per wave   │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.7  │ Write (Uncached 32B) │ 0.0        │ 0.0        │ 0.0        │ Req per wave   │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.8  │ Write (64B)          │ 0.0        │ 0.0        │ 0.0        │ Req per wave   │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.9  │ HBM Write            │ 0.01       │ 0.01       │ 0.01       │ Req per wave   │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.10 │ Read Latency         │ 276.25     │ 276.25     │ 276.25     │ Cycles         │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.11 │ Write Latency        │ 375.56     │ 375.56     │ 375.56     │ Cycles         │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.12 │ Atomic Latency       │            │            │            │ Cycles         │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.13 │ Read Stall           │ 0.0        │ 0.0        │ 0.0        │ Pct            │
├─────────┼──────────────────────┼────────────┼────────────┼────────────┼────────────────┤
│ 17.2.14 │ Write Stall          │ 0.0        │ 0.0        │ 0.0        │ Pct            │
╘═════════╧══════════════════════╧════════════╧════════════╧════════════╧════════════════╛
17.3 L2 Cache Accesses
╒═════════╤════════════════════╤══════════╤══════════╤══════════╤═════════════════╕
│ Index   │ Metric             │      Avg │      Min │      Max │ Unit            │
╞═════════╪════════════════════╪══════════╪══════════╪══════════╪═════════════════╡
│ 17.3.0  │ Req                │ 32945.33 │ 32945.33 │ 32945.33 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.1  │ Streaming Req      │     0.00 │     0.00 │     0.00 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.2  │ Read Req           │ 32881.34 │ 32881.34 │ 32881.34 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.3  │ Write Req          │     0.00 │     0.00 │     0.00 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.4  │ Atomic Req         │    64.00 │    64.00 │    64.00 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.5  │ Probe Req          │     0.00 │     0.00 │     0.00 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.6  │ Hits               │   171.59 │   171.59 │   171.59 │ Hits per wave   │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.7  │ Misses             │ 32773.74 │ 32773.74 │ 32773.74 │ Misses per wave │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.8  │ Cache Hit          │     0.52 │     0.52 │     0.52 │ Pct             │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.9  │ Writeback          │     0.02 │     0.02 │     0.02 │ per wave        │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.10 │ NC Req             │     0.05 │     0.05 │     0.05 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.11 │ UC Req             │     0.29 │     0.29 │     0.29 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.12 │ CC Req             │     0.00 │     0.00 │     0.00 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.13 │ RW Req             │ 32945.00 │ 32945.00 │ 32945.00 │ Req per wave    │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.14 │ Writeback (Normal) │     0.00 │     0.00 │     0.00 │ per wave        │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.15 │ Writeback (TC Req) │     0.00 │     0.00 │     0.00 │ per wave        │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.16 │ Evict (Normal)     │ 32742.27 │ 32742.27 │ 32742.27 │ per wave        │
├─────────┼────────────────────┼──────────┼──────────┼──────────┼─────────────────┤
│ 17.3.17 │ Evict (TC Req)     │     0.00 │     0.00 │     0.00 │ per wave        │
╘═════════╧════════════════════╧══════════╧══════════╧══════════╧═════════════════╛</code></pre>
<p>Profiling information of this level of detail is available, and it can be useful once it is determined that the high-level speed-of-light statistics indicate there may be a performance issue in the code that hits a specific hardware subsystem.</p>
<p>Looking at the L1 stats, we see: - L1 Total Req (<code>16.3.0</code>) and L1 Read Req (<code>16.3.1</code>) show we generate a lot of L1 requests - L1 Cache Hit Rate (<code>16.3.7</code>) shows half the requests have to go out to the L2</p>
<p>Looking at the L2 (<code>17.3</code>, <code>17.2</code>) data, we see: - L2 Req (<code>17.3.0</code>) is 32945.33 - L2 Read Req (<code>17.3.2</code>) is 32881.84 - L2 Hits (<code>17.3.6</code>) is 171.59 - L2 Misses (<code>17.3.7</code>) is 32773.74 - We are issuing a lot of requests to the L2 (<code>17.3.0</code>,<code>17.3.2</code>), but we almost never find the data in the L2 (<code>17.3.6</code>, <code>17.3.7</code>). - L2 Read Bandwidth (<code>17.2.0</code>) is consequently very high, the L2 always has to go out to HBM to find data.</p>
<p>This data indicates that we should be able to make better usage of our memory system, so let’s apply the algorithmic optimization present in <code>solution.cpp</code>:</p>
<pre><code>cd solution
make
./solution.exe</code></pre>
<p>(<em>simulated output</em>)</p>
<pre><code>yAx time: 0.4 ms</code></pre>
<p>It should be noted again that algorithmic optimizations are usually the most expensive optimizations to implement, as they usually entail re-conceptualizing the problem in a way that allows for a more efficient solution. However, as we see here, algorithmic optimization <em>can</em> result in impressive speedups. A better runtime is not proof that we are using our caches more efficiently, we have to profile the solution:</p>
<pre><code>omniperf profile -n solution --no-roof -- ./solution.exe</code></pre>
<p>(<em>output omitted</em>)</p>
<pre><code>omniperf analyze -p workloads/solution/mi200 --dispatch 1 --metric 16.3 16.4 17.3 17.2</code></pre>
<p>The output for the solution should look something like:</p>
<pre><code>--------
Analyze
--------


--------------------------------------------------------------------------------
0. Top Stat
╒════╤══════════════════════════════════════════╤═════════╤═══════════╤════════════╤══════════════╤════════╕
│    │ KernelName                               │   Count │   Sum(ns) │   Mean(ns) │   Median(ns) │    Pct │
╞════╪══════════════════════════════════════════╪═════════╪═══════════╪════════════╪══════════════╪════════╡
│  0 │ yax(double*, double*, double*, int, int, │    1.00 │ 415516.00 │  415516.00 │    415516.00 │ 100.00 │
│    │  double*)                                │         │           │            │              │        │
╘════╧══════════════════════════════════════════╧═════════╧═══════════╧════════════╧══════════════╧════════╛


--------------------------------------------------------------------------------
16. Vector L1 Data Cache
16.3 L1D Cache Accesses
╒═════════╤═════════════════════╤══════════╤══════════╤══════════╤════════════════╕
│ Index   │ Metric              │      Avg │      Min │      Max │ Unit           │
╞═════════╪═════════════════════╪══════════╪══════════╪══════════╪════════════════╡
│ 16.3.0  │ Total Req           │ 16448.00 │ 16448.00 │ 16448.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.1  │ Read Req            │ 16384.00 │ 16384.00 │ 16384.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.2  │ Write Req           │     0.00 │     0.00 │     0.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.3  │ Atomic Req          │    64.00 │    64.00 │    64.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.4  │ Cache BW            │  1292.37 │  1292.37 │  1292.37 │ Gb/s           │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.5  │ Cache Accesses      │  4097.00 │  4097.00 │  4097.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.6  │ Cache Hits          │  2864.00 │  2864.00 │  2864.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.7  │ Cache Hit Rate      │    69.90 │    69.90 │    69.90 │ Pct            │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.8  │ Invalidate          │     0.00 │     0.00 │     0.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.9  │ L1-L2 BW            │ 78912.00 │ 78912.00 │ 78912.00 │ Bytes per wave │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.10 │ L1-L2 Read          │  1232.00 │  1232.00 │  1232.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.11 │ L1-L2 Write         │     0.00 │     0.00 │     0.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.12 │ L1-L2 Atomic        │     1.00 │     1.00 │     1.00 │ Req per wave   │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.13 │ L1 Access Latency   │   946.51 │   946.51 │   946.51 │ Cycles         │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.14 │ L1-L2 Read Latency  │   755.41 │   755.41 │   755.41 │ Cycles         │
├─────────┼─────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 16.3.15 │ L1-L2 Write Latency │   875.86 │   875.86 │   875.86 │ Cycles         │
╘═════════╧═════════════════════╧══════════╧══════════╧══════════╧════════════════╛
16.4 L1D - L2 Transactions
╒═════════╤═════════════╤════════╤═════════════╤═════════╤═════════╤═════════╤══════════════╕
│ Index   │ Metric      │ Xfer   │ Coherency   │     Avg │     Min │     Max │ Unit         │
╞═════════╪═════════════╪════════╪═════════════╪═════════╪═════════╪═════════╪══════════════╡
│ 16.4.0  │ NC - Read   │ Read   │ NC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.1  │ UC - Read   │ Read   │ UC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.2  │ CC - Read   │ Read   │ CC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.3  │ RW - Read   │ Read   │ RW          │ 1232.00 │ 1232.00 │ 1232.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.4  │ RW - Write  │ Write  │ RW          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.5  │ NC - Write  │ Write  │ NC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.6  │ UC - Write  │ Write  │ UC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.7  │ CC - Write  │ Write  │ CC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.8  │ NC - Atomic │ Atomic │ NC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.9  │ UC - Atomic │ Atomic │ UC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.10 │ CC - Atomic │ Atomic │ CC          │    0.00 │    0.00 │    0.00 │ Req per wave │
├─────────┼─────────────┼────────┼─────────────┼─────────┼─────────┼─────────┼──────────────┤
│ 16.4.11 │ RW - Atomic │ Atomic │ RW          │    1.00 │    1.00 │    1.00 │ Req per wave │
╘═════════╧═════════════╧════════╧═════════════╧═════════╧═════════╧═════════╧══════════════╛


--------------------------------------------------------------------------------
17. L2 Cache
17.2 L2 - Fabric Transactions
╒═════════╤══════════════════════╤══════════╤══════════╤══════════╤════════════════╕
│ Index   │ Metric               │ Avg      │ Min      │ Max      │ Unit           │
╞═════════╪══════════════════════╪══════════╪══════════╪══════════╪════════════════╡
│ 17.2.0  │ Read BW              │ 65688.72 │ 65688.72 │ 65688.72 │ Bytes per wave │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.1  │ Write BW             │ 0.02     │ 0.02     │ 0.02     │ Bytes per wave │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.2  │ Read (32B)           │ 0.0      │ 0.0      │ 0.0      │ Req per wave   │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.3  │ Read (Uncached 32B)  │ 0.27     │ 0.27     │ 0.27     │ Req per wave   │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.4  │ Read (64B)           │ 1026.39  │ 1026.39  │ 1026.39  │ Req per wave   │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.5  │ HBM Read             │ 1026.51  │ 1026.51  │ 1026.51  │ Req per wave   │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.6  │ Write (32B)          │ 0.0      │ 0.0      │ 0.0      │ Req per wave   │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.7  │ Write (Uncached 32B) │ 0.0      │ 0.0      │ 0.0      │ Req per wave   │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.8  │ Write (64B)          │ 0.0      │ 0.0      │ 0.0      │ Req per wave   │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.9  │ HBM Write            │ 0.0      │ 0.0      │ 0.0      │ Req per wave   │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.10 │ Read Latency         │ 700.24   │ 700.24   │ 700.24   │ Cycles         │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.11 │ Write Latency        │ 398.0    │ 398.0    │ 398.0    │ Cycles         │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.12 │ Atomic Latency       │          │          │          │ Cycles         │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.13 │ Read Stall           │ 0.0      │ 0.0      │ 0.0      │ Pct            │
├─────────┼──────────────────────┼──────────┼──────────┼──────────┼────────────────┤
│ 17.2.14 │ Write Stall          │ 0.0      │ 0.0      │ 0.0      │ Pct            │
╘═════════╧══════════════════════╧══════════╧══════════╧══════════╧════════════════╛
17.3 L2 Cache Accesses
╒═════════╤════════════════════╤════════╤════════╤════════╤═════════════════╕
│ Index   │ Metric             │    Avg │    Min │    Max │ Unit            │
╞═════════╪════════════════════╪════════╪════════╪════════╪═════════════════╡
│ 17.3.0  │ Req                │ 617.41 │ 617.41 │ 617.41 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.1  │ Streaming Req      │   0.00 │   0.00 │   0.00 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.2  │ Read Req           │ 616.41 │ 616.41 │ 616.41 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.3  │ Write Req          │   0.00 │   0.00 │   0.00 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.4  │ Atomic Req         │   1.00 │   1.00 │   1.00 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.5  │ Probe Req          │   0.00 │   0.00 │   0.00 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.6  │ Hits               │ 104.03 │ 104.03 │ 104.03 │ Hits per wave   │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.7  │ Misses             │ 513.39 │ 513.39 │ 513.39 │ Misses per wave │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.8  │ Cache Hit          │  16.85 │  16.85 │  16.85 │ Pct             │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.9  │ Writeback          │   0.02 │   0.02 │   0.02 │ per wave        │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.10 │ NC Req             │   0.03 │   0.03 │   0.03 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.11 │ UC Req             │   0.13 │   0.13 │   0.13 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.12 │ CC Req             │   0.00 │   0.00 │   0.00 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.13 │ RW Req             │ 617.25 │ 617.25 │ 617.25 │ Req per wave    │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.14 │ Writeback (Normal) │   0.00 │   0.00 │   0.00 │ per wave        │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.15 │ Writeback (TC Req) │   0.00 │   0.00 │   0.00 │ per wave        │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.16 │ Evict (Normal)     │ 481.25 │ 481.25 │ 481.25 │ per wave        │
├─────────┼────────────────────┼────────┼────────┼────────┼─────────────────┤
│ 17.3.17 │ Evict (TC Req)     │   0.00 │   0.00 │   0.00 │ per wave        │
╘═════════╧════════════════════╧════════╧════════╧════════╧═════════════════╛</code></pre>
<p>Looking at the L1 data, we see: - L1 Cache Hit Rate (<code>16.3.7</code>) has increased about 20%. - L1 Total Req (<code>16.3.0</code>) has decreased by ~32x, 16448 compared to 524368 previously. - This results in fewer requests going out to the L2.</p>
<p>Looking at the L2 data, we see: - L2 Req (<code>17.3.0</code>) has decreased by ~53x, 617.4 compared to 32945.35 previously. - L2 Cache Hit (<code>17.3.8</code>) is orders of magnitude higher than before: 16.85% compared to 0.52% previously. - L2 Hits (<code>17.3.6</code>) is slightly lower than before: 104 compared to 171 - L2 Misses (<code>17.3.7</code>) has decreased by ~64x, 513 compared to 32773 - L2 Read bandwidth (<code>17.2.0</code>) has decreased due to the decrease in L2 misses. - We have orders of magnitude fewer requests going out to HBM than we did previously, which explains our observed speedup.</p>
<h3 id="solution-roofline-analysis-1">Solution Roofline Analysis</h3>
<p>As a final step, we should check how this new implementation stacks up with the roofline. These plots can be generated with:</p>
<pre><code>omniperf profile -n solution_roof_only --roof-only --kernel-names -- ./solution.exe</code></pre>
<p>The plots will appear as PDF files in the <code>./workloads/solution_roof_only/mi200</code> directory, if generated on MI200 hardware.</p>
<p>They are also provided below for easy reference:</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Roofline Legend</th>
<th>Roofline Plot</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise5_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise1_problem_kernelName_legend.png"/></td>
<td><img src="exercise5_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>As the Omniperf stats indicate, we are moving most data through the L1, which shows in the roofline as a decrease in Arithmetic Intensity for that cache layer. We have a high hit rate in L1, with a fairly low hit rate in L2, and we end up having to go to HBM much less frequently than we did previously, thus our HBM bandwidth has decreased as a result of more efficient usage of our memory system.</p>
<h3 id="roofline-comparison-4">Roofline Comparison</h3>
<p>The comparison of these two rooflines is confusing, due to the fact that these algorithms use the memory system very differently. It is important to keep in mind that our solution runs <strong>29x</strong> faster than the problem.</p>
<table>
<thead>
<tr class="header">
<th>Roofline Type</th>
<th>Problem Roofline</th>
<th>Solution Roofline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FP32</td>
<td><img src="exercise5_problem_roofline_fp32.png"/></td>
<td><img src="exercise5_solution_roofline_fp32.png"/></td>
</tr>
<tr class="even">
<td>FP16/INT8</td>
<td><img src="exercise5_problem_roofline_int8_fp16.png"/></td>
<td><img src="exercise5_solution_roofline_int8_fp16.png"/></td>
</tr>
</tbody>
</table>
<p>We see a significant speedup from problem to solution, but on the roofline it is difficult to determine which implementation is using the hardware more efficiently. The problem seems to be better, as the HBM point is very close to the achievable bandwidth, while the performance of the solution points seem to decrease. The roofline, though useful for estimating efficiencies of kernels, still only shows one perspective of performance.</p>
<h3 id="summary-and-take-aways-4">Summary and Take-aways</h3>
<p>This algorithmic optimization is able to work more efficiently out of the L1, generating far fewer L2 requests that require expensive memory operations. Algorithmic optimizations are all but guaranteed to have significant development overhead, but finding a more efficient algorithm can have large impacts to performance. If profiling reveals inefficient use of the memory hardware, it could be worth thinking about alternative algorithms.</p>
</body>
</html>
